# lab_02

### Основы синтаксиса JS  

**Циклы, ветвления, массивы**  

---  

## task 01  

Написать **функцию** генерации массива случайных целых чисел.  
Аргументы функции: длина массива, диапазон генерации случайного целого числа (min, max). Имя функции: getArray(len, mn, mx).  
Функцию разместить в отдельном модуле - utils.js и проверить её работу, вызывая из отдельной программы.  

# task 02  

Написать **функцию** бинарного поиска числа в отсортированном массиве целых чисел.  
Если число не находится, возвращать -1.  
Сравнить среднее количество шагов при линейном поиске и при бинарном.  

# task 03  

Написать **функцию** интерполяционного поиска числа в отсортированном массиве.  
Если число не находится, возвращать -1.  
Сравнить среднее количество шагов при интерполяционном поиске и при бинарном.  

При интерполяционном поиске диапазон поиска делят не на две равные части (как в бинарном), а на две неравные - нужно вычислить из пропорции:  

- где именно может находиться искомый элемент - ближе к началу, к середине, к концу оставшейся части диапазона поиска.  

Например, оставшаяся часть - от arr[0]=100 до arr[20]=180, а искомое число X=110.  
Очевидно, что при более-менее равномерном распределении позиция числа X ближе к arr[0], чем к arr[20], поэтому лучше диапазон делить не пополам, а в отношении разницы искомого числа и величины числа на левой границе к разнице чисел между правой и левой границей.  


## task 04  

- написать **функцию** бинарного поиска заданного слова в списке слов русского языка  
- список слов загрузить из `words_utf.txt`  
- проверить работу своей функции на списке разыскиваемых слов из файла `words_utf.txt`  
- ваша функция должна возвращать индекс позиции разыскиваемого слова в общем списке слов  
- доделать функцию чтобы она показывала сколько шагов поиска было сделано  

```txt
- в процессе испытаний Вы обнаружите, что не все слова  
  находятся в общем списке слов (хотя они там на самом деле есть)  
- требуется выяснить причины и исправить код  
```

Для чтения текстового файла можете использовать:  
`let txt = require('fs').readFileSync()`  

Для получения списка строк из `txt` можно разбить сторку с помощью `txt.split('\n')` на массив строк.  

Далее уже работаете с массивом.  

---  







> ...  

```txt

```

---  

Изучаем методы работы с массивами в JS  

Теория по методам тут (заранее почитайте):  

- [Мой учебник, Глава 1](https://pcoding.ru/pdf/jsFuncCoding.pdf)  
- [MDN rus Array](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Indexed_collections#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B_array)  

---  

**Задание ___**  

Дан контейнер, который нужно заполнить предметами для транспортировки.  
У каждого предмета есть масса и его ценность.  
Цель: наполнить контейнер предметами так,  
чтобы общая ценность взятых вещей была максимальна.  
Идеальный случай, если все предметы можно взять -  
тогда будет собрана максимально возможная ценность.  
Однако, для контейнера определено ограничение: M кг.  

Есть простой способ найти решение, близкое к оптимальному - Жадный алгоритм.  
Нужно:  

1) отсортировать объекты по убыванию и  
  - сортировать по показателю: отношение ценности к весу предмета  
  
2) выбирать из отсортированного по убыванию массива от лучшего к худшему  
  - пока не будет превышено заданное в задаче ограничение по вместимости контейнера  

Написать функцию, которая по данным из файла - items.json  
определит приблизительно максимально возможную сумму взятых предметов для M = 200.  

Для чтения данных из файла можно использовать такой подход:  
`let array = require('.\items.json');`  
Для контроля проверьте, что попало в массив array:  
`console.log(array);`

---  
---  

**Задание ___**  

Дан контейнер, который нужно заполнить предметами для транспортировки.  
У каждого предмета есть масса и его ценность.  
Цель: наполнить контейнер предметами так,  
чтобы общая ценность взятых вещей была максимальна.  
Идеальный случай, если все предметы можно взять -  
тогда будет собрана максимально возможная ценность.  
Однако, для контейнера определено ограничение: M кг.  

Чтобы найти действительно оптимальное решение требуется сделать перебор всех возможных комбинаций предметов.  


Написать функцию, которая по данным, заданным во входом файле - items.json  
определит максимально возможную сумму взятых предметов для M = 200.  

---  
